package container

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"reddock/pkg/config"
	"reddock/pkg/ui"
)

type DockerfileGenerator struct {
	config        *config.Config
	containerName string
	runtime       Runtime
	workDir       string
	addons        []string
}

func NewDockerfileGenerator(containerName string) *DockerfileGenerator {
	cfg, err := config.Load()
	if err != nil {
		fmt.Printf("Warning: Failed to load config: %v\n", err)
		cfg = config.GetDefault()
	}
	return &DockerfileGenerator{
		config:        cfg,
		containerName: containerName,
		runtime:       NewRuntime(),
		workDir:       "/tmp/reddock-build",
		addons:        []string{},
	}
}

// SetWorkDir sets the working directory for building
func (g *DockerfileGenerator) SetWorkDir(dir string) {
	g.workDir = dir
}

// AddAddon adds an addon to include in Dockerfile
func (g *DockerfileGenerator) AddAddon(addonName string) {
	g.addons = append(g.addons, addonName)
}

// SetAddons sets the list of addons to include
func (g *DockerfileGenerator) SetAddons(addons []string) {
	g.addons = addons
}

// Generate creates a Dockerfile content string
func (g *DockerfileGenerator) Generate() (string, error) {
	container := g.config.GetContainer(g.containerName)
	if container == nil {
		return "", fmt.Errorf("Container '%s' is not found", g.containerName)
	}

	gpuParam := "auto"
	if container.GPUMode != "" {
		gpuParam = container.GPUMode
	}

	var dockerfile strings.Builder

	// Base image
	dockerfile.WriteString(fmt.Sprintf("# Dockerfile for %s\n", container.Name))
	dockerfile.WriteString("# Generated by reddock\n")
	dockerfile.WriteString("# DO NOT EDIT THE DOCKERFILE UNLESS YOU KNOW WHAT ARE YOU DOING!\n\n")
	dockerfile.WriteString(fmt.Sprintf("FROM %s\n\n", container.ImageURL))

	// Addon COPY instructions
	if len(g.addons) > 0 {
		dockerfile.WriteString("# Addon layers\n")
		for _, addon := range g.addons {
			// Each addon gets its own COPY instruction
			// The addons prepare their files in directories named after them
			dockerfile.WriteString(fmt.Sprintf("COPY %s /\n", addon))
		}
		dockerfile.WriteString("\n")
	}

	// Boot arguments
	dockerfile.WriteString("# Redroid boot arguments\n")
	dockerfile.WriteString(fmt.Sprintf("CMD [\"androidboot.redroid_gpu_mode=%s\"]\n", gpuParam))

	return dockerfile.String(), nil
}

// GenerateWithCustomBase creates a Dockerfile with custom base image
func (g *DockerfileGenerator) GenerateWithCustomBase(baseImage string) (string, error) {
	gpuParam := "auto"

	container := g.config.GetContainer(g.containerName)
	if container != nil && container.GPUMode != "" {
		gpuParam = container.GPUMode
	}

	var dockerfile strings.Builder

	dockerfile.WriteString("# Custom Dockerfile\n")
	dockerfile.WriteString("# Generated by reddock\n")
	dockerfile.WriteString("# DO NOT EDIT THE DOCKERFILE UNLESS YOU KNOW WHAT ARE YOU DOING!\n\n")
	dockerfile.WriteString(fmt.Sprintf("FROM %s\n\n", baseImage))

	// Addon COPY instructions
	if len(g.addons) > 0 {
		dockerfile.WriteString("# Addon layers\n")
		for _, addon := range g.addons {
			dockerfile.WriteString(fmt.Sprintf("COPY %s /\n", addon))
		}
		dockerfile.WriteString("\n")
	}

	// Boot arguments
	dockerfile.WriteString("# Redroid boot arguments\n")
	dockerfile.WriteString(fmt.Sprintf("CMD [\"androidboot.redroid_gpu_mode=%s\"]\n", gpuParam))

	return dockerfile.String(), nil
}

// Show displays the Dockerfile content
func (g *DockerfileGenerator) Show() error {
	dockerfile, err := g.Generate()
	if err != nil {
		return err
	}

	fmt.Println("\n" + strings.Repeat("=", 50))
	fmt.Println("Generated Dockerfile:")
	fmt.Println(strings.Repeat("=", 50))
	fmt.Println(dockerfile)
	fmt.Println(strings.Repeat("=", 50))
	return nil
}

// SaveToFile saves the Dockerfile to a file
func (g *DockerfileGenerator) SaveToFile(path string) error {
	dockerfile, err := g.Generate()
	if err != nil {
		return err
	}

	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("Failed to create directory: %v", err)
	}

	if err := os.WriteFile(path, []byte(dockerfile), 0644); err != nil {
		return fmt.Errorf("Failed to write Dockerfile: %v", err)
	}

	return nil
}

// Edit opens the Dockerfile in nano for editing
func (g *DockerfileGenerator) Edit() error {
	// Generate Dockerfile content
	dockerfile, err := g.Generate()
	if err != nil {
		return err
	}

	// Create temp file for editing
	dockerfilePath := filepath.Join(g.workDir, "Dockerfile")
	if err := os.MkdirAll(g.workDir, 0755); err != nil {
		return fmt.Errorf("Failed to create work directory: %v", err)
	}

	if err := os.WriteFile(dockerfilePath, []byte(dockerfile), 0644); err != nil {
		return fmt.Errorf("Failed to write Dockerfile: %v", err)
	}

	fmt.Println("\n Opening Dockerfile in nano editor...")
	fmt.Println("   Save with: Ctrl+O, Enter")
	fmt.Println("   Exit with: Ctrl+X")
	fmt.Println()

	// Open nano editor
	cmd := exec.Command("nano", dockerfilePath)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		// Try vim if nano is not available
		cmd = exec.Command("vi", dockerfilePath)
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("Failed to open editor (tried nano and vi): %v", err)
		}
	}

	fmt.Printf("\nDockerfile saved at: %s\n", dockerfilePath)
	return nil
}

// EditAndBuild opens editor and then builds the image
func (g *DockerfileGenerator) EditAndBuild(targetImage string) error {
	// First edit the Dockerfile
	if err := g.Edit(); err != nil {
		return err
	}

	// Ask user if they want to build
	fmt.Print("\nDo you want to build the image now? [Y/n]: ")
	var response string
	fmt.Scanln(&response)

	if response != "" && strings.ToLower(response) != "y" && strings.ToLower(response) != "yes" {
		fmt.Println("Build cancelled.")
		return nil
	}

	return g.Build(targetImage)
}

// Build builds a Docker image from the saved Dockerfile
func (g *DockerfileGenerator) Build(targetImage string) error {
	container := g.config.GetContainer(g.containerName)
	if container != nil && strings.HasPrefix(container.ImageURL, "redroid/redroid:") {
		fmt.Printf("Pulling official Redroid image %s...\n", container.ImageURL)
		if err := g.runtime.PullImage(container.ImageURL); err != nil {
			fmt.Printf("Warning: Failed to pull base image: %v\n", err)
		}
	}

	dockerfilePath := filepath.Join(g.workDir, "Dockerfile")

	// Check if Dockerfile exists
	if _, err := os.Stat(dockerfilePath); os.IsNotExist(err) {
		return fmt.Errorf("Dockerfile not found at %s. Run Edit() first or SaveToFile()", dockerfilePath)
	}

	spinner := ui.NewSpinner(fmt.Sprintf("Building image %s...", targetImage))
	spinner.Start()

	buildArgs := []string{"build", "-t", targetImage, g.workDir}
	if g.runtime.Name() == "docker" {
		buildArgs = []string{"buildx", "build", "--load", "-t", targetImage, g.workDir}
	}
	cmd := g.runtime.Command(buildArgs...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		spinner.Finish("Failed to build image")
		fmt.Println(string(output))
		return fmt.Errorf("Build failed: %v", err)
	}

	spinner.Finish(fmt.Sprintf("Successfully built %s", targetImage))
	return nil
}

// CommitContainer commits a running container to a new image
// This is useful for saving changes made while the container is running
func (g *DockerfileGenerator) CommitContainer(newImageName, message string) error {
	if !g.runtime.IsRunning(g.containerName) {
		return fmt.Errorf("Container '%s' is not running", g.containerName)
	}

	spinner := ui.NewSpinner(fmt.Sprintf("Committing container %s to %s...", g.containerName, newImageName))
	spinner.Start()

	args := []string{"commit"}
	if message != "" {
		args = append(args, "-m", message)
	}
	args = append(args, g.containerName, newImageName)

	cmd := g.runtime.Command(args...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		spinner.Finish("Failed to commit container")
		fmt.Println(string(output))
		return fmt.Errorf("Commit failed: %v", err)
	}

	spinner.Finish(fmt.Sprintf("Successfully committed to %s", newImageName))
	return nil
}

// CopyToContainer copies files from host to a running container
// This is the core function for installing addons to a running container
func (g *DockerfileGenerator) CopyToContainer(srcPath, destPath string) error {
	if !g.runtime.IsRunning(g.containerName) {
		return fmt.Errorf("Container '%s' is not running", g.containerName)
	}

	spinner := ui.NewSpinner(fmt.Sprintf("Copying to container %s...", g.containerName))
	spinner.Start()

	// docker cp <src> <container>:<dest>
	target := fmt.Sprintf("%s:%s", g.containerName, destPath)
	cmd := g.runtime.Command("cp", srcPath, target)
	output, err := cmd.CombinedOutput()

	if err != nil {
		spinner.Finish("Failed to copy files")
		fmt.Println(string(output))
		return fmt.Errorf("Copy failed: %v", err)
	}

	spinner.Finish(fmt.Sprintf("Successfully copied to %s", destPath))
	return nil
}

// ExecInContainer executes a command inside the running container
func (g *DockerfileGenerator) ExecInContainer(command string) error {
	if !g.runtime.IsRunning(g.containerName) {
		return fmt.Errorf("Container '%s' is not running", g.containerName)
	}

	cmd := g.runtime.Command("exec", g.containerName, "sh", "-c", command)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// InstallAddonToRunningContainer installs addon files to a running container
// This follows the redroid-script approach of copying files directly
func (g *DockerfileGenerator) InstallAddonToRunningContainer(addonDir, addonName string) error {
	if !g.runtime.IsRunning(g.containerName) {
		return fmt.Errorf("Container '%s' is not running. Start it first with 'reddock start %s'",
			g.containerName, g.containerName)
	}

	// The addon directory should contain the extracted files
	// We copy the contents to the root of the container
	srcPath := filepath.Join(addonDir, addonName)

	if _, err := os.Stat(srcPath); os.IsNotExist(err) {
		return fmt.Errorf("Addon directory not found: %s", srcPath)
	}

	spinner := ui.NewSpinner(fmt.Sprintf("Installing %s to running container...", addonName))
	spinner.Start()

	// Walk through the addon directory and copy each item
	entries, err := os.ReadDir(srcPath)
	if err != nil {
		spinner.Finish("Failed to read addon directory")
		return fmt.Errorf("Failed to read addon directory: %v", err)
	}

	for _, entry := range entries {
		itemPath := filepath.Join(srcPath, entry.Name())
		destPath := "/"

		// docker cp <src> <container>:<dest>
		target := fmt.Sprintf("%s:%s", g.containerName, destPath)
		cmd := g.runtime.Command("cp", itemPath, target)
		if output, err := cmd.CombinedOutput(); err != nil {
			spinner.Finish(fmt.Sprintf("Failed to copy %s", entry.Name()))
			fmt.Println(string(output))
			return fmt.Errorf("Failed to copy %s: %v", entry.Name(), err)
		}
	}

	spinner.Finish(fmt.Sprintf("Successfully installed %s", addonName))

	fmt.Println("\nNote: The container may need to be restarted for changes to take effect.")
	fmt.Println("To commit these changes to a new image, use: reddock dockerfile commit <container> <new-image-name>")

	return nil
}

// ShowCurrentDockerfile displays the Dockerfile that was used or would be used
func (g *DockerfileGenerator) ShowCurrentDockerfile() {
	dockerfilePath := filepath.Join(g.workDir, "Dockerfile")

	if content, err := os.ReadFile(dockerfilePath); err == nil {
		fmt.Println("\n" + strings.Repeat("=", 50))
		fmt.Println("Current Dockerfile:")
		fmt.Println(strings.Repeat("=", 50))
		fmt.Println(string(content))
		fmt.Println(strings.Repeat("=", 50))
	} else {
		// Generate and show
		g.Show()
	}
}

// GetDockerfilePath returns the path to the Dockerfile
func (g *DockerfileGenerator) GetDockerfilePath() string {
	return filepath.Join(g.workDir, "Dockerfile")
}

// Cleanup removes the work directory
func (g *DockerfileGenerator) Cleanup() error {
	return os.RemoveAll(g.workDir)
}

// Interactive provides an interactive workflow for creating/editing Dockerfile
func (g *DockerfileGenerator) Interactive() error {
	fmt.Println("\n╔════════════════════════════════════════════════════╗")
	fmt.Println("║       Reddock Dockerfile Creator & Manager         ║")
	fmt.Println("╚════════════════════════════════════════════════════╝")

	// Show current generated Dockerfile
	if err := g.Show(); err != nil {
		return err
	}

	fmt.Println("\nHere's the options below:")
	fmt.Println("  1. Edit the Dockerfile with nano")
	fmt.Println("  2. Build image from Dockerfile")
	fmt.Println("  3. Edit and Build")
	fmt.Println("  4. Commit running container to image")
	fmt.Println("  5. Install addon to running container")
	fmt.Println("  6. Exit")

	fmt.Print("\nChoose an option that you want to do [1-6]: ")
	var choice string
	fmt.Scanln(&choice)

	switch choice {
	case "1":
		return g.Edit()

	case "2":
		fmt.Print("Enter target image name (e.g., myredroid:latest): ")
		var imageName string
		fmt.Scanln(&imageName)
		if imageName == "" {
			imageName = fmt.Sprintf("reddock/%s:custom", g.containerName)
		}
		// Save first if not exists
		dockerfilePath := g.GetDockerfilePath()
		if _, err := os.Stat(dockerfilePath); os.IsNotExist(err) {
			if err := g.SaveToFile(dockerfilePath); err != nil {
				return err
			}
		}
		return g.Build(imageName)

	case "3":
		fmt.Print("Enter target image name (e.g., myredroid:latest): ")
		var imageName string
		fmt.Scanln(&imageName)
		if imageName == "" {
			imageName = fmt.Sprintf("reddock/%s:custom", g.containerName)
		}
		return g.EditAndBuild(imageName)

	case "4":
		if !g.runtime.IsRunning(g.containerName) {
			return fmt.Errorf("container '%s' is not running", g.containerName)
		}
		fmt.Print("Enter new image name: ")
		var imageName string
		fmt.Scanln(&imageName)
		if imageName == "" {
			imageName = fmt.Sprintf("reddock/%s:committed", g.containerName)
		}
		fmt.Print("Enter commit messages (optional): ")
		var message string
		fmt.Scanln(&message)
		return g.CommitContainer(imageName, message)

	case "5":
		fmt.Print("Enter addon name (e.g., houdini, ndk, gapps): ")
		var addonName string
		fmt.Scanln(&addonName)
		if addonName == "" {
			return fmt.Errorf("Addon name is required!")
		}
		// Use default addon work directory
		addonDir := "/tmp/reddock-addons"
		return g.InstallAddonToRunningContainer(addonDir, addonName)

	case "6":
		fmt.Println("You can open this again by running 'reddock dockerfile interactive'.")
		return nil

	default:
		return fmt.Errorf("Invalid option: %s", choice)
	}
}
